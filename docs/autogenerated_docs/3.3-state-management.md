# State Management

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [src/crewai/flow/flow.py](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py)
- [tests/test_multimodal_validation.py](https://github.com/crewAIInc/crewAI/blob/81bd81e5/tests/test_multimodal_validation.py)
- [tests/utilities/test_events.py](https://github.com/crewAIInc/crewAI/blob/81bd81e5/tests/utilities/test_events.py)

</details>



State management in CrewAI flows provides persistent data storage and retrieval capabilities that maintain flow context across method executions, restarts, and failures. The system supports both dictionary-based and strongly-typed Pydantic model states with automatic persistence, restoration, and type validation.

For information about flow creation and structure, see [Flow Creation and Structure](#3.1). For details about flow persistence backends, see [Flow Visualization and Events](#3.4).

## State Models and Types

The Flow system supports two primary state types: dictionary states for flexible data storage and Pydantic BaseModel states for structured, validated data.

### FlowState Base Class

The `FlowState` class serves as the foundation for all structured flow states, ensuring each state instance has a unique identifier.

```mermaid
classDiagram
    class FlowState {
        +str id
        +__init__()
    }
    
    class BaseModel {
        +model_validate()
        +model_dump()
        +dict()
    }
    
    class CustomFlowState {
        +str id
        +custom_field1
        +custom_field2
    }
    
    BaseModel <|-- FlowState
    FlowState <|-- CustomFlowState
    
    note for FlowState "Unique ID generated via uuid4()"
    note for CustomFlowState "User-defined state models inherit ID field"
```

Sources: [src/crewai/flow/flow.py:49-56](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L49-L56)

### Generic Type Support

Flow classes use generic type parameters to enforce state type consistency throughout the flow lifecycle.

```mermaid
graph TB
    subgraph "Type Parameters"
        T["T: TypeVar bound to Union[Dict, BaseModel]"]
        StateT["StateT: TypeVar for validation"]
    end
    
    subgraph "Flow Generic Class"
        FlowGeneric["Flow[T]"]
        FlowDict["Flow[dict]"]
        FlowModel["Flow[CustomState]"]
    end
    
    subgraph "State Types"
        DictState["Dict[str, Any]"]
        ModelState["BaseModel subclass"]
    end
    
    T --> FlowGeneric
    FlowGeneric --> FlowDict
    FlowGeneric --> FlowModel
    FlowDict --> DictState
    FlowModel --> ModelState
    
    note for T "Ensures type consistency across flow methods"
    note for StateT "Used for runtime type validation"
```

Sources: [src/crewai/flow/flow.py:58-65](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L58-L65), [src/crewai/flow/flow.py:436-456](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L436-L456)

## State Lifecycle Management

State management follows a structured lifecycle from initialization through persistence, with automatic ID generation and type validation at each stage.

### State Initialization

The `_create_initial_state` method handles state creation with different initialization patterns based on the state type.

```mermaid
flowchart TD
    Start["Flow.__init__()"] --> CheckInitial{"initial_state is None?"}
    
    CheckInitial -->|Yes| CheckTypeParam{"Has _initial_state_T?"}
    CheckInitial -->|No| CheckStateType{"isinstance(initial_state, type)?"}
    
    CheckTypeParam -->|Yes| CreateFromType["Create from type parameter"]
    CheckTypeParam -->|No| CreateDict["Create dict with UUID"]
    
    CheckStateType -->|Yes| CheckFlowState{"Subclass of FlowState?"}
    CheckStateType -->|No| CheckInstance{"Dict or BaseModel instance?"}
    
    CheckFlowState -->|Yes| CreateFlowState["Create FlowState instance"]
    CheckFlowState -->|No| CheckBaseModel{"Subclass of BaseModel?"}
    
    CheckBaseModel -->|Yes| ValidateID["Validate 'id' field exists"]
    CheckBaseModel -->|No| CheckDict{"state_type is dict?"}
    
    CheckDict -->|Yes| CreateDict
    CheckDict -->|No| Error["Raise TypeError"]
    
    CheckInstance -->|Dict| CopyDict["Copy dict and add UUID if missing"]
    CheckInstance -->|BaseModel| CopyModel["Copy BaseModel with same values"]
    CheckInstance -->|Other| Error
    
    ValidateID --> CreateModel["Create BaseModel instance"]
    CreateFromType --> CreateDict
    CreateFlowState --> SetID["Set UUID if missing"]
    CreateModel --> SetID
    CopyDict --> Done["Return initialized state"]
    CopyModel --> Done
    CreateDict --> Done
    SetID --> Done
```

Sources: [src/crewai/flow/flow.py:513-594](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L513-L594)

### State Updates and Modification

The `_initialize_state` method provides controlled state updates while preserving essential fields like the flow ID.

```mermaid
sequenceDiagram
    participant Flow
    participant State
    participant Validator
    
    Flow->>State: _initialize_state(inputs)
    
    alt State is dict
        State->>State: Preserve current ID
        State->>State: Update fields from inputs
        State->>State: Ensure ID exists
    else State is BaseModel
        State->>State: Get current state as dict
        State->>State: Merge with inputs
        State->>Validator: Validate new state
        Validator->>State: Create new instance
        State->>Flow: Update _state reference
    end
    
    Note over Flow,Validator: Type validation prevents invalid updates
```

Sources: [src/crewai/flow/flow.py:640-693](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L640-L693)

## State Persistence and Restoration

State management integrates with persistence backends to maintain flow state across executions and enable flow resumption after interruptions.

### Persistence Integration

The Flow class coordinates with `FlowPersistence` backends to save and restore state data.

```mermaid
graph LR
    subgraph "Flow Execution"
        Flow["Flow Instance"]
        State["_state: T"]
        FlowID["flow_id: str"]
    end
    
    subgraph "Persistence Layer"
        Persistence["FlowPersistence"]
        Storage["Storage Backend"]
    end
    
    subgraph "State Operations"
        Save["save_state()"]
        Load["load_state()"]
        Restore["_restore_state()"]
    end
    
    Flow --> State
    State --> FlowID
    Flow --> Persistence
    Persistence --> Storage
    
    Flow --> Save
    Save --> Persistence
    Load --> Persistence
    Restore --> Flow
    
    note for FlowID "UUID used as persistence key"
    note for Storage "Implementation-specific backend"
```

Sources: [src/crewai/flow/flow.py:476](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L476), [src/crewai/flow/flow.py:694-727](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L694-L727)

### State Restoration Process

The `_restore_state` method rebuilds flow state from persisted data with proper type validation.

```mermaid
flowchart TD
    Start["_restore_state(stored_state)"] --> ValidateID{"stored_state has 'id'?"}
    
    ValidateID -->|No| ErrorNoID["Raise ValueError: 'Stored state must have id'"]
    ValidateID -->|Yes| CheckCurrentType{"Current state type?"}
    
    CheckCurrentType -->|Dict| ClearDict["Clear current dict"]
    CheckCurrentType -->|BaseModel| GetModelClass["Get BaseModel class"]
    
    ClearDict --> UpdateDict["Update with stored_state"]
    GetModelClass --> CheckValidation{"Has model_validate?"}
    
    CheckValidation -->|Yes| ValidateV2["Use Pydantic v2 validation"]
    CheckValidation -->|No| CheckParseObj{"Has parse_obj?"}
    
    CheckParseObj -->|Yes| ValidateV1["Use Pydantic v1 validation"]
    CheckParseObj -->|No| Fallback["Use fallback constructor"]
    
    ValidateV2 --> CreateNew["Create new instance"]
    ValidateV1 --> CreateNew
    Fallback --> CreateNew
    UpdateDict --> Done["State restored"]
    CreateNew --> Done
```

Sources: [src/crewai/flow/flow.py:694-727](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L694-L727)

## Flow State Access and Properties

The Flow class provides controlled access to state data through properties and methods that maintain type safety and consistency.

### State Access Patterns

```mermaid
classDiagram
    class Flow {
        -_state: T
        +state: T
        +flow_id: str
        +method_outputs: List[Any]
        +_copy_state(): T
        +_update_state_field(field: str, value: Any)
        +_apply_state_updates(updates: Dict)
    }
    
    class FlowState {
        +id: str
    }
    
    class Dict {
        +get(key): Any
        +update(other): None
    }
    
    Flow --> FlowState : "structured state"
    Flow --> Dict : "flexible state"
    
    note for Flow "Property access ensures read-only external access"
    note for FlowState "Pydantic validation for structured data"
    note for Dict "Direct field access for flexible schemas"
```

Sources: [src/crewai/flow/flow.py:595-639](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L595-L639), [src/crewai/flow/flow.py:779-794](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L779-L794)

## Type Validation and Safety

The system includes comprehensive type validation to ensure state consistency and prevent runtime errors during flow execution.

### Type Validation Function

The `ensure_state_type` function provides runtime type checking for state objects.

```mermaid
flowchart TD
    Start["ensure_state_type(state, expected_type)"] --> CheckExpected{"expected_type is dict?"}
    
    CheckExpected -->|Yes| CheckStateDict{"isinstance(state, dict)?"}
    CheckExpected -->|No| CheckBaseModel{"issubclass(expected_type, BaseModel)?"}
    
    CheckStateDict -->|Yes| ReturnDict["Return cast(StateT, state)"]
    CheckStateDict -->|No| ErrorDict["Raise TypeError: Expected dict"]
    
    CheckBaseModel -->|Yes| CheckStateModel{"isinstance(state, expected_type)?"}
    CheckBaseModel -->|No| ErrorInvalidType["Raise TypeError: Invalid expected_type"]
    
    CheckStateModel -->|Yes| ReturnModel["Return cast(StateT, state)"]
    CheckStateModel -->|No| ErrorModel["Raise TypeError: Type mismatch"]
    
    ReturnDict --> Done["Validated state"]
    ReturnModel --> Done
```

Sources: [src/crewai/flow/flow.py:67-105](https://github.com/crewAIInc/crewAI/blob/81bd81e5/src/crewai/flow/flow.py#L67-L105)

## State Management in Flow Execution

State management integrates seamlessly with flow execution, providing automatic state capture and restoration during method execution.

### Execution Context Integration

```mermaid
sequenceDiagram
    participant Client
    participant Flow
    participant Method
    participant Persistence
    participant EventBus
    
    Client->>Flow: kickoff_async(inputs)
    
    alt Has persistence and ID in inputs
        Flow->>Persistence: load_state(id)
        Persistence->>Flow: stored_state
        Flow->>Flow: _restore_state(stored_state)
    end
    
    Flow->>Flow: _initialize_state(inputs)
    Flow->>EventBus: FlowStartedEvent
    
    loop For each method execution
        Flow->>Method: _execute_method(method_name, method)
        Method->>EventBus: MethodExecutionStartedEvent(state=copy)
        Method->>Method: Execute method logic
        Method->>Flow: Return result
        Flow->>EventBus: MethodExecutionFinishedEvent(state=copy)
    end
    
    Flow->>EventBus: FlowFinishedEvent
    Flow->>Client: final_output
    
    note over Flow,Persistence: State automatically preserved across method calls
    note over EventBus: State snapshots included in events
```