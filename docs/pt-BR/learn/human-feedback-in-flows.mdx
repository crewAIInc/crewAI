---
title: Feedback Humano em Flows
description: Aprenda como integrar feedback humano diretamente nos seus CrewAI Flows usando o decorador @human_feedback
icon: user-check
mode: "wide"
---

## Vis√£o Geral

O decorador `@human_feedback` permite fluxos de trabalho human-in-the-loop (HITL) diretamente nos CrewAI Flows. Ele permite pausar a execu√ß√£o do flow, apresentar a sa√≠da para um humano revisar, coletar seu feedback e, opcionalmente, rotear para diferentes listeners com base no resultado do feedback.

Isso √© particularmente valioso para:

- **Garantia de qualidade**: Revisar conte√∫do gerado por IA antes de ser usado downstream
- **Port√µes de decis√£o**: Deixar humanos tomarem decis√µes cr√≠ticas em fluxos automatizados
- **Fluxos de aprova√ß√£o**: Implementar padr√µes de aprovar/rejeitar/revisar
- **Refinamento interativo**: Coletar feedback para melhorar sa√≠das iterativamente

```mermaid
flowchart LR
    A[M√©todo do Flow] --> B[Sa√≠da Gerada]
    B --> C[Humano Revisa]
    C --> D{Feedback}
    D -->|emit especificado| E[LLM Mapeia para Outcome]
    D -->|sem emit| F[HumanFeedbackResult]
    E --> G["@listen('approved')"]
    E --> H["@listen('rejected')"]
    F --> I[Pr√≥ximo Listener]
```

## In√≠cio R√°pido

Aqui est√° a maneira mais simples de adicionar feedback humano a um flow:

```python Code
from crewai.flow.flow import Flow, start, listen
from crewai.flow.human_feedback import human_feedback

class SimpleReviewFlow(Flow):
    @human_feedback(request="Por favor, revise este conte√∫do:")
    @start()
    def generate_content(self):
        return "Este √© um conte√∫do gerado por IA que precisa de revis√£o."

    @listen(generate_content)
    def process_feedback(self, result):
        print(f"Conte√∫do: {result.output}")
        print(f"Humano disse: {result.feedback}")

flow = SimpleReviewFlow()
flow.kickoff()
```

Quando este flow √© executado, ele ir√°:
1. Executar `generate_content` e retornar a string
2. Exibir a sa√≠da para o usu√°rio com a mensagem de solicita√ß√£o
3. Aguardar o usu√°rio digitar o feedback (ou pressionar Enter para pular)
4. Passar um objeto `HumanFeedbackResult` para `process_feedback`

## O Decorador @human_feedback

### Par√¢metros

| Par√¢metro | Tipo | Obrigat√≥rio | Descri√ß√£o |
|-----------|------|-------------|-----------|
| `request` | `str` | Sim | A mensagem mostrada ao humano junto com a sa√≠da do m√©todo |
| `emit` | `Sequence[str]` | N√£o | Lista de poss√≠veis outcomes. O feedback √© mapeado para um destes, que dispara decoradores `@listen` |
| `llm` | `str \| BaseLLM` | Quando `emit` especificado | LLM usado para interpretar o feedback e mapear para um outcome |
| `default_outcome` | `str` | N√£o | Outcome a usar se nenhum feedback for fornecido. Deve estar em `emit` |
| `metadata` | `dict` | N√£o | Dados adicionais para integra√ß√µes enterprise |

### Uso B√°sico (Sem Roteamento)

Quando voc√™ n√£o especifica `emit`, o decorador simplesmente coleta o feedback e passa um `HumanFeedbackResult` para o pr√≥ximo listener:

```python Code
@human_feedback(request="O que voc√™ acha desta an√°lise?")
@start()
def analyze_data(self):
    return "Resultados da an√°lise: Receita aumentou 15%, custos diminu√≠ram 8%"

@listen(analyze_data)
def handle_feedback(self, result):
    # result √© um HumanFeedbackResult
    print(f"An√°lise: {result.output}")
    print(f"Feedback: {result.feedback}")
```

### Roteamento com emit

Quando voc√™ especifica `emit`, o decorador se torna um roteador. O feedback livre do humano √© interpretado por um LLM e mapeado para um dos outcomes especificados:

```python Code
@human_feedback(
    request="Voc√™ aprova este conte√∫do para publica√ß√£o?",
    emit=["approved", "rejected", "needs_revision"],
    llm="gpt-4o-mini",
    default_outcome="needs_revision",
)
@start()
def review_content(self):
    return "Rascunho do post do blog aqui..."

@listen("approved")
def publish(self, result):
    print(f"Publicando! Usu√°rio disse: {result.feedback}")

@listen("rejected")
def discard(self, result):
    print(f"Descartando. Motivo: {result.feedback}")

@listen("needs_revision")
def revise(self, result):
    print(f"Revisando baseado em: {result.feedback}")
```

<Tip>
O LLM usa sa√≠das estruturadas (function calling) quando dispon√≠vel para garantir que a resposta seja um dos seus outcomes especificados. Isso torna o roteamento confi√°vel e previs√≠vel.
</Tip>

## HumanFeedbackResult

O dataclass `HumanFeedbackResult` cont√©m todas as informa√ß√µes sobre uma intera√ß√£o de feedback humano:

```python Code
from crewai.flow.human_feedback import HumanFeedbackResult

@dataclass
class HumanFeedbackResult:
    output: Any              # A sa√≠da original do m√©todo mostrada ao humano
    feedback: str            # O texto bruto do feedback do humano
    outcome: str | None      # O outcome mapeado (se emit foi especificado)
    timestamp: datetime      # Quando o feedback foi recebido
    method_name: str         # Nome do m√©todo decorado
    metadata: dict           # Qualquer metadata passado ao decorador
```

### Acessando em Listeners

Quando um listener √© disparado por um m√©todo `@human_feedback` com `emit`, ele recebe o `HumanFeedbackResult`:

```python Code
@listen("approved")
def on_approval(self, result: HumanFeedbackResult):
    print(f"Sa√≠da original: {result.output}")
    print(f"Feedback do usu√°rio: {result.feedback}")
    print(f"Outcome: {result.outcome}")  # "approved"
    print(f"Recebido em: {result.timestamp}")
```

## Acessando o Hist√≥rico de Feedback

A classe `Flow` fornece dois atributos para acessar o feedback humano:

### last_human_feedback

Retorna o `HumanFeedbackResult` mais recente:

```python Code
@listen(some_method)
def check_feedback(self):
    if self.last_human_feedback:
        print(f"√öltimo feedback: {self.last_human_feedback.feedback}")
```

### human_feedback_history

Uma lista de todos os objetos `HumanFeedbackResult` coletados durante o flow:

```python Code
@listen(final_step)
def summarize(self):
    print(f"Total de feedbacks coletados: {len(self.human_feedback_history)}")
    for i, fb in enumerate(self.human_feedback_history):
        print(f"{i+1}. {fb.method_name}: {fb.outcome or 'sem roteamento'}")
```

<Warning>
Cada `HumanFeedbackResult` √© adicionado a `human_feedback_history`, ent√£o m√∫ltiplos passos de feedback n√£o sobrescrevem uns aos outros. Use esta lista para acessar todo o feedback coletado durante o flow.
</Warning>

## Exemplo Completo: Fluxo de Aprova√ß√£o de Conte√∫do

Aqui est√° um exemplo completo implementando um fluxo de revis√£o e aprova√ß√£o de conte√∫do:

<CodeGroup>

```python Code
from crewai.flow.flow import Flow, start, listen
from crewai.flow.human_feedback import human_feedback, HumanFeedbackResult
from pydantic import BaseModel


class ContentState(BaseModel):
    topic: str = ""
    draft: str = ""
    final_content: str = ""
    revision_count: int = 0


class ContentApprovalFlow(Flow[ContentState]):
    """Um flow que gera conte√∫do e obt√©m aprova√ß√£o humana."""

    @start()
    def get_topic(self):
        self.state.topic = input("Sobre qual t√≥pico devo escrever? ")
        return self.state.topic

    @listen(get_topic)
    def generate_draft(self, topic):
        # Em uso real, isso chamaria um LLM
        self.state.draft = f"# {topic}\n\nEste √© um rascunho sobre {topic}..."
        return self.state.draft

    @human_feedback(
        request="Por favor, revise este rascunho. Responda 'approved', 'rejected', ou forne√ßa feedback de revis√£o:",
        emit=["approved", "rejected", "needs_revision"],
        llm="gpt-4o-mini",
        default_outcome="needs_revision",
    )
    @listen(generate_draft)
    def review_draft(self, draft):
        return draft

    @listen("approved")
    def publish_content(self, result: HumanFeedbackResult):
        self.state.final_content = result.output
        print("\n‚úÖ Conte√∫do aprovado e publicado!")
        print(f"Coment√°rio do revisor: {result.feedback}")
        return "published"

    @listen("rejected")
    def handle_rejection(self, result: HumanFeedbackResult):
        print("\n‚ùå Conte√∫do rejeitado")
        print(f"Motivo: {result.feedback}")
        return "rejected"

    @listen("needs_revision")
    def revise_content(self, result: HumanFeedbackResult):
        self.state.revision_count += 1
        print(f"\nüìù Revis√£o #{self.state.revision_count} solicitada")
        print(f"Feedback: {result.feedback}")

        # Em um flow real, voc√™ pode voltar para generate_draft
        # Para este exemplo, apenas reconhecemos
        return "revision_requested"


# Executar o flow
flow = ContentApprovalFlow()
result = flow.kickoff()
print(f"\nFlow conclu√≠do. Revis√µes solicitadas: {flow.state.revision_count}")
```

```text Output
Sobre qual t√≥pico devo escrever? Seguran√ßa em IA

==================================================
OUTPUT FOR REVIEW:
==================================================
# Seguran√ßa em IA

Este √© um rascunho sobre Seguran√ßa em IA...
==================================================

Por favor, revise este rascunho. Responda 'approved', 'rejected', ou forne√ßa feedback de revis√£o:
(Press Enter to skip, or type your feedback)

Your feedback: Parece bom, aprovado!

‚úÖ Conte√∫do aprovado e publicado!
Coment√°rio do revisor: Parece bom, aprovado!

Flow conclu√≠do. Revis√µes solicitadas: 0
```

</CodeGroup>

## Combinando com Outros Decoradores

O decorador `@human_feedback` funciona com outros decoradores de flow. A ordem importa:

```python Code
# Correto: @human_feedback envolve o decorador de flow
@human_feedback(request="Revise isto:")
@start()
def my_start_method(self):
    return "content"

@human_feedback(request="Revise isto tamb√©m:")
@listen(other_method)
def my_listener(self, data):
    return f"processed: {data}"
```

<Tip>
Coloque `@human_feedback` como o decorador mais externo (primeiro/topo) para que ele execute ap√≥s o m√©todo completar e possa capturar o valor de retorno.
</Tip>

## Melhores Pr√°ticas

### 1. Escreva Mensagens de Solicita√ß√£o Claras

O par√¢metro `request` √© o que o humano v√™. Torne-o acion√°vel:

```python Code
# ‚úÖ Bom - claro e acion√°vel
@human_feedback(request="Este resumo captura com precis√£o os pontos-chave? Responda 'sim' ou explique o que est√° faltando:")

# ‚ùå Ruim - vago
@human_feedback(request="Revise isto:")
```

### 2. Escolha Outcomes Significativos

Ao usar `emit`, escolha outcomes que mapeiem naturalmente para respostas humanas:

```python Code
# ‚úÖ Bom - outcomes em linguagem natural
emit=["approved", "rejected", "needs_more_detail"]

# ‚ùå Ruim - t√©cnico ou pouco claro
emit=["state_1", "state_2", "state_3"]
```

### 3. Sempre Forne√ßa um Outcome Padr√£o

Use `default_outcome` para lidar com casos onde usu√°rios pressionam Enter sem digitar:

```python Code
@human_feedback(
    request="Aprovar? (pressione Enter para solicitar revis√£o)",
    emit=["approved", "needs_revision"],
    llm="gpt-4o-mini",
    default_outcome="needs_revision",  # Padr√£o seguro
)
```

### 4. Use o Hist√≥rico de Feedback para Trilhas de Auditoria

Acesse `human_feedback_history` para criar logs de auditoria:

```python Code
@listen(final_step)
def create_audit_log(self):
    log = []
    for fb in self.human_feedback_history:
        log.append({
            "step": fb.method_name,
            "outcome": fb.outcome,
            "feedback": fb.feedback,
            "timestamp": fb.timestamp.isoformat(),
        })
    return log
```

### 5. Trate Feedback Roteado e N√£o Roteado

Ao projetar flows, considere se voc√™ precisa de roteamento:

| Cen√°rio | Use |
|---------|-----|
| Revis√£o simples, s√≥ precisa do texto do feedback | Sem `emit` |
| Precisa ramificar para caminhos diferentes baseado na resposta | Use `emit` |
| Port√µes de aprova√ß√£o com aprovar/rejeitar/revisar | Use `emit` |
| Coletando coment√°rios apenas para logging | Sem `emit` |

## Documenta√ß√£o Relacionada

- [Vis√£o Geral de Flows](/pt-BR/concepts/flows) - Aprenda sobre CrewAI Flows
- [Gerenciamento de Estado em Flows](/pt-BR/guides/flows/mastering-flow-state) - Gerenciando estado em flows
- [Roteamento com @router](/pt-BR/concepts/flows#router) - Mais sobre roteamento condicional
- [Input Humano na Execu√ß√£o](/pt-BR/learn/human-input-on-execution) - Input humano no n√≠vel de task
