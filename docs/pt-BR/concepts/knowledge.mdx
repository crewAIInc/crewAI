---
title: Knowledge
description: O que √© knowledge em CrewAI e como us√°-lo.
icon: book
---

## Vis√£o Geral

Knowledge no CrewAI √© um sistema poderoso que permite que agentes de IA acessem e utilizem fontes de informa√ß√£o externas durante suas tarefas.
Pense nisso como dar aos seus agentes uma biblioteca de refer√™ncia que eles podem consultar enquanto trabalham.

<Info>
  Principais benef√≠cios de usar Knowledge:
  - Aprimorar agentes com informa√ß√µes espec√≠ficas do dom√≠nio
  - Apoiar decis√µes com dados do mundo real
  - Manter contexto entre conversas
  - Fundamentar respostas em informa√ß√µes factuais
</Info>

## Exemplos de In√≠cio R√°pido

<Tip>
Para Fontes de Knowledge baseadas em arquivos, certifique-se de colocar seus arquivos em um diret√≥rio `knowledge` na raiz do seu projeto.
Al√©m disso, use caminhos relativos do diret√≥rio `knowledge` ao criar a fonte.
</Tip>

### Exemplo B√°sico de Knowledge com String

```python Code
from crewai import Agent, Task, Crew, Process, LLM
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# Create a knowledge source
content = "Users name is John. He is 30 years old and lives in San Francisco."
string_source = StringKnowledgeSource(content=content)

# Create an LLM with a temperature of 0 to ensure deterministic outputs
llm = LLM(model="gpt-4o-mini", temperature=0)

# Create an agent with the knowledge store
agent = Agent(
    role="About User",
    goal="You know everything about the user.",
    backstory="You are a master at understanding people and their preferences.",
    verbose=True,
    allow_delegation=False,
    llm=llm,
)

task = Task(
    description="Answer the following questions about the user: {question}",
    expected_output="An answer to the question.",
    agent=agent,
)

crew = Crew(
    agents=[agent],
    tasks=[task],
    verbose=True,
    process=Process.sequential,
    knowledge_sources=[string_source], # Enable knowledge by adding the sources here
)

result = crew.kickoff(inputs={"question": "What city does John live in and how old is he?"})
```

### Exemplo de Knowledge com Conte√∫do Web

<Note>
  Voc√™ precisa instalar `docling` para o seguinte exemplo funcionar: `uv add docling`
</Note>

```python Code
from crewai import LLM, Agent, Crew, Process, Task
from crewai.knowledge.source.crew_docling_source import CrewDoclingSource

# Create a knowledge source from web content
content_source = CrewDoclingSource(
    file_paths=[
        "https://lilianweng.github.io/posts/2024-11-28-reward-hacking",
        "https://lilianweng.github.io/posts/2024-07-07-hallucination",
    ],
)

# Create an LLM with a temperature of 0 to ensure deterministic outputs
llm = LLM(model="gpt-4o-mini", temperature=0)

# Create an agent with the knowledge store
agent = Agent(
    role="About papers",
    goal="You know everything about the papers.",
    backstory="You are a master at understanding papers and their content.",
    verbose=True,
    allow_delegation=False,
    llm=llm,
)

task = Task(
    description="Answer the following questions about the papers: {question}",
    expected_output="An answer to the question.",
    agent=agent,
)

crew = Crew(
    agents=[agent],
    tasks=[task],
    verbose=True,
    process=Process.sequential,
    knowledge_sources=[content_source],
)

result = crew.kickoff(
    inputs={"question": "What is the reward hacking paper about? Be sure to provide sources."}
)
```

## Fontes de Knowledge Suportadas

O CrewAI suporta v√°rios tipos de fontes de knowledge prontas para uso:

<CardGroup cols={2}>
  <Card title="Fontes de Texto" icon="text">
    - Strings brutas
    - Arquivos de texto (.txt)
    - Documentos PDF
  </Card>
  <Card title="Dados Estruturados" icon="table">
    - Arquivos CSV
    - Planilhas Excel
    - Documentos JSON
  </Card>
</CardGroup>

### Fonte de Knowledge de Arquivo de Texto
```python
from crewai.knowledge.source.text_file_knowledge_source import TextFileKnowledgeSource

text_source = TextFileKnowledgeSource(
    file_paths=["document.txt", "another.txt"]
)
```

### Fonte de Knowledge PDF
```python
from crewai.knowledge.source.pdf_knowledge_source import PDFKnowledgeSource

pdf_source = PDFKnowledgeSource(
    file_paths=["document.pdf", "another.pdf"]
)
```

### Fonte de Knowledge CSV
```python
from crewai.knowledge.source.csv_knowledge_source import CSVKnowledgeSource

csv_source = CSVKnowledgeSource(
    file_paths=["data.csv"]
)
```

### Fonte de Knowledge Excel
```python
from crewai.knowledge.source.excel_knowledge_source import ExcelKnowledgeSource

excel_source = ExcelKnowledgeSource(
    file_paths=["spreadsheet.xlsx"]
)
```

### Fonte de Knowledge JSON
```python
from crewai.knowledge.source.json_knowledge_source import JSONKnowledgeSource

json_source = JSONKnowledgeSource(
    file_paths=["data.json"]
)
```

<Note>
  Certifique-se de criar a pasta ./knowledge. Todos os arquivos de origem (ex: .txt, .pdf, .xlsx, .json) devem ser colocados nesta pasta para gerenciamento centralizado.
</Note>

## Knowledge de Agente vs Crew: Guia Completo

<Info>
**Entendendo os N√≠veis de Knowledge**: O CrewAI suporta knowledge tanto no n√≠vel de agente quanto de crew. Esta se√ß√£o esclarece exatamente como cada um funciona, quando s√£o inicializados, e aborda equ√≠vocos comuns sobre depend√™ncias.
</Info>

### Como a Inicializa√ß√£o de Knowledge Realmente Funciona

Aqui est√° exatamente o que acontece quando voc√™ usa knowledge:

#### Knowledge no N√≠vel do Agente (Independente)
```python
from crewai import Agent, Task, Crew
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# Agent with its own knowledge - NO crew knowledge needed
specialist_knowledge = StringKnowledgeSource(
    content="Specialized technical information for this agent only"
)

specialist_agent = Agent(
    role="Technical Specialist",
    goal="Provide technical expertise",
    backstory="Expert in specialized technical domains",
    knowledge_sources=[specialist_knowledge]  # Agent-specific knowledge
)

task = Task(
    description="Answer technical questions",
    agent=specialist_agent,
    expected_output="Technical answer"
)

# No crew-level knowledge required
crew = Crew(
    agents=[specialist_agent],
    tasks=[task]
)

result = crew.kickoff()  # Agent knowledge works independently
```

#### O Que Acontece Durante `crew.kickoff()`

Quando voc√™ chama `crew.kickoff()`, aqui est√° a sequ√™ncia exata:

```python
# During kickoff
for agent in self.agents:
    agent.crew = self  # Agent gets reference to crew
    agent.set_knowledge(crew_embedder=self.embedder)  # Agent knowledge initialized
    agent.create_agent_executor()
```

#### Independ√™ncia de Armazenamento

Cada n√≠vel de knowledge usa cole√ß√µes de armazenamento independentes:

```python
# Agent knowledge storage
agent_collection_name = agent.role  # e.g., "Technical Specialist"

# Crew knowledge storage
crew_collection_name = "crew"

# Both stored in same ChromaDB instance but different collections
# Path: ~/.local/share/CrewAI/{project}/knowledge/
#   ‚îú‚îÄ‚îÄ crew/                    # Crew knowledge collection
#   ‚îú‚îÄ‚îÄ Technical Specialist/    # Agent knowledge collection
#   ‚îî‚îÄ‚îÄ Another Agent Role/      # Another agent's collection
```

### Exemplos Completos Funcionais

#### Exemplo 1: Knowledge Apenas do Agente
```python
from crewai import Agent, Task, Crew
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# Agent-specific knowledge
agent_knowledge = StringKnowledgeSource(
    content="Agent-specific information that only this agent needs"
)

agent = Agent(
    role="Specialist",
    goal="Use specialized knowledge",
    backstory="Expert with specific knowledge",
    knowledge_sources=[agent_knowledge],
    embedder={  # Agent can have its own embedder
        "provider": "openai",
        "config": {"model": "text-embedding-3-small"}
    }
)

task = Task(
    description="Answer using your specialized knowledge",
    agent=agent,
    expected_output="Answer based on agent knowledge"
)

# No crew knowledge needed
crew = Crew(agents=[agent], tasks=[task])
result = crew.kickoff()  # Works perfectly
```

#### Exemplo 2: Knowledge Tanto do Agente Quanto da Crew
```python
# Crew-wide knowledge (shared by all agents)
crew_knowledge = StringKnowledgeSource(
    content="Company policies and general information for all agents"
)

# Agent-specific knowledge
specialist_knowledge = StringKnowledgeSource(
    content="Technical specifications only the specialist needs"
)

specialist = Agent(
    role="Technical Specialist",
    goal="Provide technical expertise",
    backstory="Technical expert",
    knowledge_sources=[specialist_knowledge]  # Agent-specific
)

generalist = Agent(
    role="General Assistant",
    goal="Provide general assistance",
    backstory="General helper"
    # No agent-specific knowledge
)

crew = Crew(
    agents=[specialist, generalist],
    tasks=[...],
    knowledge_sources=[crew_knowledge]  # Crew-wide knowledge
)

# Result:
# - specialist gets: crew_knowledge + specialist_knowledge
# - generalist gets: crew_knowledge only
```

#### Exemplo 3: M√∫ltiplos Agentes com Knowledge Diferente
```python
# Different knowledge for different agents
sales_knowledge = StringKnowledgeSource(content="Sales procedures and pricing")
tech_knowledge = StringKnowledgeSource(content="Technical documentation")
support_knowledge = StringKnowledgeSource(content="Support procedures")

sales_agent = Agent(
    role="Sales Representative",
    knowledge_sources=[sales_knowledge],
    embedder={"provider": "openai", "config": {"model": "text-embedding-3-small"}}
)

tech_agent = Agent(
    role="Technical Expert",
    knowledge_sources=[tech_knowledge],
    embedder={"provider": "ollama", "config": {"model": "mxbai-embed-large"}}
)

support_agent = Agent(
    role="Support Specialist",
    knowledge_sources=[support_knowledge]
    # Will use crew embedder as fallback
)

crew = Crew(
    agents=[sales_agent, tech_agent, support_agent],
    tasks=[...],
    embedder={  # Fallback embedder for agents without their own
        "provider": "google",
        "config": {"model": "text-embedding-004"}
    }
)

# Each agent gets only their specific knowledge
# Each can use different embedding providers
```

<Tip>
Diferente da recupera√ß√£o de um banco de dados vetorial usando uma ferramenta, agentes pr√©-carregados com knowledge n√£o precisar√£o de uma persona de recupera√ß√£o ou tarefa.
Simplesmente adicione as fontes de knowledge relevantes que seu agente ou crew precisa para funcionar.

As fontes de knowledge podem ser adicionadas no n√≠vel do agente ou da crew.
As fontes de knowledge no n√≠vel da crew ser√£o usadas por **todos os agentes** na crew.
As fontes de knowledge no n√≠vel do agente ser√£o usadas pelo **agente espec√≠fico** que √© pr√©-carregado com o knowledge.
</Tip>

## Configura√ß√£o de Knowledge

Voc√™ pode configurar a configura√ß√£o de knowledge para a crew ou agente.

```python Code
from crewai.knowledge.knowledge_config import KnowledgeConfig

knowledge_config = KnowledgeConfig(results_limit=10, score_threshold=0.5)

agent = Agent(
    ...
    knowledge_config=knowledge_config
)
```

<Tip>
  `results_limit`: √© o n√∫mero de documentos relevantes a retornar. Padr√£o √© 3.
  `score_threshold`: √© a pontua√ß√£o m√≠nima para um documento ser considerado relevante. Padr√£o √© 0.35.
</Tip>

## Par√¢metros de Knowledge Suportados

<ParamField body="sources" type="List[BaseKnowledgeSource]" required="Yes">
    Lista de fontes de knowledge que fornecem conte√∫do para ser armazenado e consultado. Pode incluir PDF, CSV, Excel, JSON, arquivos de texto ou conte√∫do de string.
</ParamField>
<ParamField body="collection_name" type="str">
    Nome da cole√ß√£o onde o knowledge ser√° armazenado. Usado para identificar diferentes conjuntos de knowledge. Padr√£o √© "knowledge" se n√£o fornecido.
</ParamField>
<ParamField body="storage" type="Optional[KnowledgeStorage]">
Configura√ß√£o de armazenamento personalizada para gerenciar como o knowledge √© armazenado e recuperado. Se n√£o fornecido, um armazenamento padr√£o ser√° criado.
</ParamField>

## Transpar√™ncia do Armazenamento de Knowledge

<Info>
**Entendendo o Armazenamento de Knowledge**: O CrewAI armazena automaticamente as fontes de knowledge em diret√≥rios espec√≠ficos da plataforma usando ChromaDB para armazenamento vetorial. Entender essas localiza√ß√µes e padr√µes ajuda com implanta√ß√µes de produ√ß√£o, depura√ß√£o e gerenciamento de armazenamento.
</Info>

### Onde o CrewAI Armazena Arquivos de Knowledge

Por padr√£o, o CrewAI usa o mesmo sistema de armazenamento que a mem√≥ria, armazenando knowledge em diret√≥rios espec√≠ficos da plataforma:

#### Localiza√ß√µes de Armazenamento Padr√£o por Plataforma

**macOS:**
```
~/Library/Application Support/CrewAI/{project_name}/
‚îî‚îÄ‚îÄ knowledge/                    # Knowledge ChromaDB files
    ‚îú‚îÄ‚îÄ chroma.sqlite3           # ChromaDB metadata
    ‚îú‚îÄ‚îÄ {collection_id}/         # Vector embeddings
    ‚îî‚îÄ‚îÄ knowledge_{collection}/  # Named collections
```

**Linux:**
```
~/.local/share/CrewAI/{project_name}/
‚îî‚îÄ‚îÄ knowledge/
    ‚îú‚îÄ‚îÄ chroma.sqlite3
    ‚îú‚îÄ‚îÄ {collection_id}/
    ‚îî‚îÄ‚îÄ knowledge_{collection}/
```

**Windows:**
```
C:\Users\{username}\AppData\Local\CrewAI\{project_name}\
‚îî‚îÄ‚îÄ knowledge\
    ‚îú‚îÄ‚îÄ chroma.sqlite3
    ‚îú‚îÄ‚îÄ {collection_id}\
    ‚îî‚îÄ‚îÄ knowledge_{collection}\
```

### Encontrando Sua Localiza√ß√£o de Armazenamento de Knowledge

Para ver exatamente onde o CrewAI est√° armazenando seus arquivos de knowledge:

```python
from crewai.utilities.paths import db_storage_path
import os

# Get the knowledge storage path
knowledge_path = os.path.join(db_storage_path(), "knowledge")
print(f"Knowledge storage location: {knowledge_path}")

# List knowledge collections and files
if os.path.exists(knowledge_path):
    print("\nKnowledge storage contents:")
    for item in os.listdir(knowledge_path):
        item_path = os.path.join(knowledge_path, item)
        if os.path.isdir(item_path):
            print(f"üìÅ Collection: {item}/")
            # Show collection contents
            try:
                for subitem in os.listdir(item_path):
                    print(f"   ‚îî‚îÄ‚îÄ {subitem}")
            except PermissionError:
                print(f"   ‚îî‚îÄ‚îÄ (permission denied)")
        else:
            print(f"üìÑ {item}")
else:
    print("No knowledge storage found yet.")
```

### Controlando Localiza√ß√µes de Armazenamento de Knowledge

#### Op√ß√£o 1: Vari√°vel de Ambiente (Recomendado)
```python
import os
from crewai import Crew

# Set custom storage location for all CrewAI data
os.environ["CREWAI_STORAGE_DIR"] = "./my_project_storage"

# All knowledge will now be stored in ./my_project_storage/knowledge/
crew = Crew(
    agents=[...],
    tasks=[...],
    knowledge_sources=[...]
)
```

#### Op√ß√£o 2: Armazenamento de Knowledge Personalizado
```python
from crewai.knowledge.storage.knowledge_storage import KnowledgeStorage
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# Create custom storage with specific embedder
custom_storage = KnowledgeStorage(
    embedder={
        "provider": "ollama",
        "config": {"model": "mxbai-embed-large"}
    },
    collection_name="my_custom_knowledge"
)

# Use with knowledge sources
knowledge_source = StringKnowledgeSource(
    content="Your knowledge content here"
)
knowledge_source.storage = custom_storage
```

#### Op√ß√£o 3: Armazenamento de Knowledge Espec√≠fico do Projeto
```python
import os
from pathlib import Path

# Store knowledge in project directory
project_root = Path(__file__).parent
knowledge_dir = project_root / "knowledge_storage"

os.environ["CREWAI_STORAGE_DIR"] = str(knowledge_dir)

# Now all knowledge will be stored in your project directory
```

### Comportamento Padr√£o do Provedor de Embedding

<Info>
**Provedor de Embedding Padr√£o**: O CrewAI usa por padr√£o embeddings da OpenAI (`text-embedding-3-small`) para armazenamento de knowledge, mesmo quando usa diferentes provedores de LLM. Voc√™ pode facilmente personalizar isso para corresponder √† sua configura√ß√£o.
</Info>

#### Entendendo o Comportamento Padr√£o
```python
from crewai import Agent, Crew, LLM
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# When using Claude as your LLM...
agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    llm=LLM(provider="anthropic", model="claude-3-sonnet")  # Using Claude
)

# CrewAI will still use OpenAI embeddings by default for knowledge
# This ensures consistency but may not match your LLM provider preference
knowledge_source = StringKnowledgeSource(content="Research data...")

crew = Crew(
    agents=[agent],
    tasks=[...],
    knowledge_sources=[knowledge_source]
    # Default: Uses OpenAI embeddings even with Claude LLM
)
```

#### Personalizando Provedores de Embedding de Knowledge
```python
# Option 1: Use Voyage AI (recommended by Anthropic for Claude users)
crew = Crew(
    agents=[agent],
    tasks=[...],
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "voyageai",  # Recommended for Claude users
        "config": {
            "api_key": "your-voyage-api-key",
            "model": "voyage-3"  # or "voyage-3-large" for best quality
        }
    }
)

# Option 2: Use local embeddings (no external API calls)
crew = Crew(
    agents=[agent],
    tasks=[...],
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "ollama",
        "config": {
            "model": "mxbai-embed-large",
            "url": "http://localhost:11434/api/embeddings"
        }
    }
)

# Option 3: Agent-level embedding customization
agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "google",
        "config": {
            "model": "models/text-embedding-004",
            "api_key": "your-google-key"
        }
    }
)
```

#### Configurando Embeddings do Azure OpenAI

Ao usar embeddings do Azure OpenAI:
1. Certifique-se de implantar o modelo de embedding na plataforma Azure primeiro
2. Ent√£o voc√™ precisa usar a seguinte configura√ß√£o:

```python
agent = Agent(
    role="Researcher",
    goal="Research topics",
    backstory="Expert researcher",
    knowledge_sources=[knowledge_source],
    embedder={
        "provider": "azure",
        "config": {
            "api_key": "your-azure-api-key",
            "model": "text-embedding-ada-002", # change to the model you are using and is deployed in Azure
            "api_base": "https://your-azure-endpoint.openai.azure.com/",
            "api_version": "2024-02-01"
        }
    }
)
```

## Recursos Avan√ßados

### Reescrita de Consulta

O CrewAI implementa um mecanismo inteligente de reescrita de consulta para otimizar a recupera√ß√£o de knowledge. Quando um agente precisa pesquisar nas fontes de knowledge, o prompt da tarefa bruto √© automaticamente transformado em uma consulta de pesquisa mais eficaz.

#### Como a Reescrita de Consulta Funciona

1. Quando um agente executa uma tarefa com fontes de knowledge dispon√≠veis, o m√©todo `_get_knowledge_search_query` √© acionado
2. O LLM do agente √© usado para transformar o prompt original da tarefa em uma consulta de pesquisa otimizada
3. Esta consulta otimizada √© ent√£o usada para recuperar informa√ß√µes relevantes das fontes de knowledge

#### Benef√≠cios da Reescrita de Consulta

<CardGroup cols={2}>
  <Card title="Precis√£o de Recupera√ß√£o Melhorada" icon="bullseye-arrow">
    Ao focar em conceitos-chave e remover conte√∫do irrelevante, a reescrita de consulta ajuda a recuperar informa√ß√µes mais relevantes.
  </Card>
  <Card title="Consci√™ncia de Contexto" icon="brain">
    As consultas reescritas s√£o projetadas para ser mais espec√≠ficas e conscientes do contexto para recupera√ß√£o de banco de dados vetorial.
  </Card>
</CardGroup>

#### Exemplo

```python
# Original task prompt
task_prompt = "Answer the following questions about the user's favorite movies: What movie did John watch last week? Format your answer in JSON."

# Behind the scenes, this might be rewritten as:
rewritten_query = "What movies did John watch last week?"
```

A consulta reescrita √© mais focada na necessidade de informa√ß√£o principal e remove instru√ß√µes irrelevantes sobre formata√ß√£o de sa√≠da.

<Tip>
  Este mecanismo √© totalmente autom√°tico e n√£o requer configura√ß√£o dos usu√°rios. O LLM do agente √© usado para realizar a reescrita da consulta, ent√£o usar um LLM mais capaz pode melhorar a qualidade das consultas reescritas.
</Tip>

### Eventos de Knowledge

O CrewAI emite eventos durante o processo de recupera√ß√£o de knowledge que voc√™ pode escutar usando o sistema de eventos. Esses eventos permitem que voc√™ monitore, depure e analise como o knowledge est√° sendo recuperado e usado pelos seus agentes.

#### Eventos de Knowledge Dispon√≠veis

- **KnowledgeRetrievalStartedEvent**: Emitido quando um agente come√ßa a recuperar knowledge das fontes
- **KnowledgeRetrievalCompletedEvent**: Emitido quando a recupera√ß√£o de knowledge √© conclu√≠da, incluindo a consulta usada e o conte√∫do recuperado
- **KnowledgeQueryStartedEvent**: Emitido quando uma consulta √†s fontes de knowledge come√ßa
- **KnowledgeQueryCompletedEvent**: Emitido quando uma consulta √© conclu√≠da com sucesso
- **KnowledgeQueryFailedEvent**: Emitido quando uma consulta √†s fontes de knowledge falha
- **KnowledgeSearchQueryFailedEvent**: Emitido quando uma consulta de pesquisa falha

#### Exemplo: Monitorando Recupera√ß√£o de Knowledge

```python
from crewai.utilities.events import (
    KnowledgeRetrievalStartedEvent,
    KnowledgeRetrievalCompletedEvent,
)
from crewai.utilities.events.base_event_listener import BaseEventListener

class KnowledgeMonitorListener(BaseEventListener):
    def setup_listeners(self, crewai_event_bus):
        @crewai_event_bus.on(KnowledgeRetrievalStartedEvent)
        def on_knowledge_retrieval_started(source, event):
            print(f"Agent '{event.agent.role}' started retrieving knowledge")

        @crewai_event_bus.on(KnowledgeRetrievalCompletedEvent)
        def on_knowledge_retrieval_completed(source, event):
            print(f"Agent '{event.agent.role}' completed knowledge retrieval")
            print(f"Query: {event.query}")
            print(f"Retrieved {len(event.retrieved_knowledge)} knowledge chunks")

# Create an instance of your listener
knowledge_monitor = KnowledgeMonitorListener()
```

Para mais informa√ß√µes sobre como usar eventos, consulte a documenta√ß√£o [Event Listeners](https://docs.crewai.com/concepts/event-listener).

### Fontes de Knowledge Personalizadas

O CrewAI permite que voc√™ crie fontes de knowledge personalizadas para qualquer tipo de dados estendendo a classe `BaseKnowledgeSource`. Vamos criar um exemplo pr√°tico que busca e processa artigos de not√≠cias espaciais.

#### Exemplo de Fonte de Knowledge de Not√≠cias Espaciais

<CodeGroup>

```python Code
from crewai import Agent, Task, Crew, Process, LLM
from crewai.knowledge.source.base_knowledge_source import BaseKnowledgeSource
import requests
from datetime import datetime
from typing import Dict, Any
from pydantic import BaseModel, Field

class SpaceNewsKnowledgeSource(BaseKnowledgeSource):
    """Knowledge source that fetches data from Space News API."""

    api_endpoint: str = Field(description="API endpoint URL")
    limit: int = Field(default=10, description="Number of articles to fetch")

    def load_content(self) -> Dict[Any, str]:
        """Fetch and format space news articles."""
        try:
            response = requests.get(
                f"{self.api_endpoint}?limit={self.limit}"
            )
            response.raise_for_status()

            data = response.json()
            articles = data.get('results', [])

            formatted_data = self.validate_content(articles)
            return {self.api_endpoint: formatted_data}
        except Exception as e:
            raise ValueError(f"Failed to fetch space news: {str(e)}")

    def validate_content(self, articles: list) -> str:
        """Format articles into readable text."""
        formatted = "Space News Articles:\n\n"
        for article in articles:
            formatted += f"""
                Title: {article['title']}
                Published: {article['published_at']}
                Summary: {article['summary']}
                News Site: {article['news_site']}
                URL: {article['url']}
                -------------------"""
        return formatted

    def add(self) -> None:
        """Process and store the articles."""
        content = self.load_content()
        for _, text in content.items():
            chunks = self._chunk_text(text)
            self.chunks.extend(chunks)

        self._save_documents()

# Create knowledge source
recent_news = SpaceNewsKnowledgeSource(
    api_endpoint="https://api.spaceflightnewsapi.net/v4/articles",
    limit=10,
)

# Create specialized agent
space_analyst = Agent(
    role="Space News Analyst",
    goal="Answer questions about space news accurately and comprehensively",
    backstory="""You are a space industry analyst with expertise in space exploration,
    satellite technology, and space industry trends. You excel at answering questions
    about space news and providing detailed, accurate information.""",
    knowledge_sources=[recent_news],
    llm=LLM(model="gpt-4", temperature=0.0)
)

# Create task that handles user questions
analysis_task = Task(
    description="Answer this question about space news: {user_question}",
    expected_output="A detailed answer based on the recent space news articles",
    agent=space_analyst
)

# Create and run the crew
crew = Crew(
    agents=[space_analyst],
    tasks=[analysis_task],
    verbose=True,
    process=Process.sequential
)

# Example usage
result = crew.kickoff(
    inputs={"user_question": "What are the latest developments in space exploration?"}
)
```

```output Output
# Agent: Space News Analyst
## Task: Answer this question about space news: What are the latest developments in space exploration?


# Agent: Space News Analyst
## Final Answer:
The latest developments in space exploration, based on recent space news articles, include the following:

1. SpaceX has received the final regulatory approvals to proceed with the second integrated Starship/Super Heavy launch, scheduled for as soon as the morning of Nov. 17, 2023. This is a significant step in SpaceX's ambitious plans for space exploration and colonization. [Source: SpaceNews](https://spacenews.com/starship-cleared-for-nov-17-launch/)

2. SpaceX has also informed the US Federal Communications Commission (FCC) that it plans to begin launching its first next-generation Starlink Gen2 satellites. This represents a major upgrade to the Starlink satellite internet service, which aims to provide high-speed internet access worldwide. [Source: Teslarati](https://www.teslarati.com/spacex-first-starlink-gen2-satellite-launch-2022/)

3. AI startup Synthetaic has raised $15 million in Series B funding. The company uses artificial intelligence to analyze data from space and air sensors, which could have significant applications in space exploration and satellite technology. [Source: SpaceNews](https://spacenews.com/ai-startup-synthetaic-raises-15-million-in-series-b-funding/)

4. The Space Force has formally established a unit within the U.S. Indo-Pacific Command, marking a permanent presence in the Indo-Pacific region. This could have significant implications for space security and geopolitics. [Source: SpaceNews](https://spacenews.com/space-force-establishes-permanent-presence-in-indo-pacific-region/)

5. Slingshot Aerospace, a space tracking and data analytics company, is expanding its network of ground-based optical telescopes to increase coverage of low Earth orbit. This could improve our ability to track and analyze objects in low Earth orbit, including satellites and space debris. [Source: SpaceNews](https://spacenews.com/slingshots-space-tracking-network-to-extend-coverage-of-low-earth-orbit/)

6. The National Natural Science Foundation of China has outlined a five-year project for researchers to study the assembly of ultra-large spacecraft. This could lead to significant advancements in spacecraft technology and space exploration capabilities. [Source: SpaceNews](https://spacenews.com/china-researching-challenges-of-kilometer-scale-ultra-large-spacecraft/)

7. The Center for AEroSpace Autonomy Research (CAESAR) at Stanford University is focusing on spacecraft autonomy. The center held a kickoff event on May 22, 2024, to highlight the industry, academia, and government collaboration it seeks to foster. This could lead to significant advancements in autonomous spacecraft technology. [Source: SpaceNews](https://spacenews.com/stanford-center-focuses-on-spacecraft-autonomy/)
```

</CodeGroup>

## Depura√ß√£o e Solu√ß√£o de Problemas

### Depurando Problemas de Knowledge

#### Verificar Inicializa√ß√£o de Knowledge do Agente
```python
from crewai import Agent, Crew, Task
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

knowledge_source = StringKnowledgeSource(content="Test knowledge")

agent = Agent(
    role="Test Agent",
    goal="Test knowledge",
    backstory="Testing",
    knowledge_sources=[knowledge_source]
)

crew = Crew(agents=[agent], tasks=[Task(...)])

# Before kickoff - knowledge not initialized
print(f"Before kickoff - Agent knowledge: {getattr(agent, 'knowledge', None)}")

crew.kickoff()

# After kickoff - knowledge initialized
print(f"After kickoff - Agent knowledge: {agent.knowledge}")
print(f"Agent knowledge collection: {agent.knowledge.storage.collection_name}")
print(f"Number of sources: {len(agent.knowledge.sources)}")
```

#### Verificar Localiza√ß√µes de Armazenamento de Knowledge
```python
import os
from crewai.utilities.paths import db_storage_path

# Check storage structure
storage_path = db_storage_path()
knowledge_path = os.path.join(storage_path, "knowledge")

if os.path.exists(knowledge_path):
    print("Knowledge collections found:")
    for collection in os.listdir(knowledge_path):
        collection_path = os.path.join(knowledge_path, collection)
        if os.path.isdir(collection_path):
            print(f"  - {collection}/")
            # Show collection contents
            for item in os.listdir(collection_path):
                print(f"    ‚îî‚îÄ‚îÄ {item}")
```

#### Testar Recupera√ß√£o de Knowledge
```python
# Test agent knowledge retrieval
if hasattr(agent, 'knowledge') and agent.knowledge:
    test_query = ["test query"]
    results = agent.knowledge.query(test_query)
    print(f"Agent knowledge results: {len(results)} documents found")

    # Test crew knowledge retrieval (if exists)
    if hasattr(crew, 'knowledge') and crew.knowledge:
        crew_results = crew.query_knowledge(test_query)
        print(f"Crew knowledge results: {len(crew_results)} documents found")
```

#### Inspecionar Cole√ß√µes de Knowledge
```python
import chromadb
from crewai.utilities.paths import db_storage_path
import os

# Connect to CrewAI's knowledge ChromaDB
knowledge_path = os.path.join(db_storage_path(), "knowledge")

if os.path.exists(knowledge_path):
    client = chromadb.PersistentClient(path=knowledge_path)
    collections = client.list_collections()

    print("Knowledge Collections:")
    for collection in collections:
        print(f"  - {collection.name}: {collection.count()} documents")

        # Sample a few documents to verify content
        if collection.count() > 0:
            sample = collection.peek(limit=2)
            print(f"    Sample content: {sample['documents'][0][:100]}...")
else:
    print("No knowledge storage found")
```

#### Verificar Processamento de Knowledge
```python
from crewai.knowledge.source.string_knowledge_source import StringKnowledgeSource

# Create a test knowledge source
test_source = StringKnowledgeSource(
    content="Test knowledge content for debugging",
    chunk_size=100,  # Small chunks for testing
    chunk_overlap=20
)

# Check chunking behavior
print(f"Original content length: {len(test_source.content)}")
print(f"Chunk size: {test_source.chunk_size}")
print(f"Chunk overlap: {test_source.chunk_overlap}")

# Process and inspect chunks
test_source.add()
print(f"Number of chunks created: {len(test_source.chunks)}")
for i, chunk in enumerate(test_source.chunks[:3]):  # Show first 3 chunks
    print(f"Chunk {i+1}: {chunk[:50]}...")
```

### Problemas Comuns de Armazenamento de Knowledge

**Erros "Arquivo n√£o encontrado":**
```python
# Ensure files are in the correct location
from crewai.utilities.constants import KNOWLEDGE_DIRECTORY
import os

knowledge_dir = KNOWLEDGE_DIRECTORY  # Usually "knowledge"
file_path = os.path.join(knowledge_dir, "your_file.pdf")

if not os.path.exists(file_path):
    print(f"File not found: {file_path}")
    print(f"Current working directory: {os.getcwd()}")
    print(f"Expected knowledge directory: {os.path.abspath(knowledge_dir)}")
```

**Erros "Incompatibilidade de dimens√£o de embedding":**
```python
# This happens when switching embedding providers
# Reset knowledge storage to clear old embeddings
crew.reset_memories(command_type='knowledge')

# Or use consistent embedding providers
crew = Crew(
    agents=[...],
    tasks=[...],
    knowledge_sources=[...],
    embedder={"provider": "openai", "config": {"model": "text-embedding-3-small"}}
)
```

**Erros "ChromaDB permiss√£o negada":**
```bash
# Fix storage permissions
chmod -R 755 ~/.local/share/CrewAI/
```

**Knowledge n√£o persistindo entre execu√ß√µes:**
```python
# Verify storage location consistency
import os
from crewai.utilities.paths import db_storage_path

print("CREWAI_STORAGE_DIR:", os.getenv("CREWAI_STORAGE_DIR"))
print("Computed storage path:", db_storage_path())
print("Knowledge path:", os.path.join(db_storage_path(), "knowledge"))
```

### Comandos de Reset de Knowledge

```python
# Reset only agent-specific knowledge
crew.reset_memories(command_type='agent_knowledge')

# Reset both crew and agent knowledge
crew.reset_memories(command_type='knowledge')

# CLI commands
# crewai reset-memories --agent-knowledge  # Agent knowledge only
# crewai reset-memories --knowledge        # All knowledge
```

### Limpando Knowledge

Se voc√™ precisar limpar o knowledge armazenado no CrewAI, voc√™ pode usar o comando `crewai reset-memories` com a op√ß√£o `--knowledge`.

```bash Command
crewai reset-memories --knowledge
```

Isso √© √∫til quando voc√™ atualizou suas fontes de knowledge e quer garantir que os agentes estejam usando as informa√ß√µes mais recentes.

## Melhores Pr√°ticas

<AccordionGroup>
  <Accordion title="Organiza√ß√£o de Conte√∫do">
    - Mantenha tamanhos de chunk apropriados para seu tipo de conte√∫do
    - Considere sobreposi√ß√£o de conte√∫do para preserva√ß√£o de contexto
    - Organize informa√ß√µes relacionadas em fontes de knowledge separadas
  </Accordion>

  <Accordion title="Dicas de Performance">
    - Ajuste tamanhos de chunk baseado na complexidade do conte√∫do
    - Configure modelos de embedding apropriados
    - Considere usar provedores de embedding locais para processamento mais r√°pido
  </Accordion>

  <Accordion title="Knowledge de Uma Vez">
    - Com a estrutura de arquivo t√≠pica fornecida pelo CrewAI, as fontes de knowledge s√£o incorporadas toda vez que o kickoff √© acionado.
    - Se as fontes de knowledge s√£o grandes, isso leva √† inefici√™ncia e lat√™ncia aumentada, pois os mesmos dados s√£o incorporados cada vez.
    - Para resolver isso, inicialize diretamente o par√¢metro knowledge em vez do par√¢metro knowledge_sources.
    - Link para a issue para ter a ideia completa [Github Issue](https://github.com/crewAIInc/crewAI/issues/2755)
  </Accordion>

  <Accordion title="Gerenciamento de Knowledge">
    - Use knowledge no n√≠vel do agente para informa√ß√µes espec√≠ficas do papel
    - Use knowledge no n√≠vel da crew para informa√ß√µes compartilhadas que todos os agentes precisam
    - Configure embedders no n√≠vel do agente se voc√™ precisar de estrat√©gias de embedding diferentes
    - Use nomenclatura consistente de cole√ß√£o mantendo pap√©is de agente descritivos
    - Teste a inicializa√ß√£o de knowledge verificando agent.knowledge ap√≥s o kickoff
    - Monitore localiza√ß√µes de armazenamento para entender onde o knowledge est√° armazenado
    - Reset knowledge apropriadamente usando os tipos de comando corretos
  </Accordion>

  <Accordion title="Melhores Pr√°ticas de Produ√ß√£o">
    - Configure `CREWAI_STORAGE_DIR` para uma localiza√ß√£o conhecida em produ√ß√£o
    - Escolha provedores de embedding expl√≠citos para corresponder √† sua configura√ß√£o de LLM e evitar conflitos de chave de API
    - Monitore o tamanho do armazenamento de knowledge conforme ele cresce com adi√ß√µes de documentos
    - Organize fontes de knowledge por dom√≠nio ou prop√≥sito usando nomes de cole√ß√£o
    - Inclua diret√≥rios de knowledge em suas estrat√©gias de backup e implanta√ß√£o
    - Configure permiss√µes de arquivo apropriadas para arquivos de knowledge e diret√≥rios de armazenamento
    - Use vari√°veis de ambiente para chaves de API e configura√ß√£o sens√≠vel
  </Accordion>
</AccordionGroup>
